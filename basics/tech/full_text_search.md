---
description: 본 페이지에서는 elastic search를 활용한 Full Text 기능을 알아 본다.
---

# 통합검색(FULL TEXT SEARCH)

## 검색개선

* 검색기능을 간소화 하고 향후 사용자 편의성 향으로 사용
* 검색기능에 대한 기능을 적절하게 향상하여 검색 효율을 최적화

## 엘라스틱서치와 관계형 디비 차이?

* 일반적으로 RDB는 행을 기반으로 데이터를 저장, 그에 반해 엘라스틱서치는 단어를 기반으로(역인덱스, Inverted Index) 저장. 이로 인한 장단점은 엘라스틱서치가 기본적으로 Nosql처럼 문서형 저장 방식으로 수정과 생성에는 엄청많은 리소스를 사용하기 되기에 권장하지 않음
* 기존 DBMS를 RDBMS로 가정한다면 테이블 지향 데이터베이스(Table oriented Database)이기 때문에 일반적인 정규화(Normalization) 방법론을 기반으로 설계해야 하지만 반면 엘라스틱서치는 NoSQL 기반의 문서 지향 데이터베이스(Document oriented Database)로 RDBMS와 같은 방법론을 적용하면 성능 저하 문제 초래

## 엘라스틱서치에서 관계형 데이터 모델링 방법은?

기존 DBMS와 달리 엘라스틱서치는 태생이 검색엔진이기 때문에 데이터의 유형, 검색 조건, 집계·시각화 여부 등에 따라 적절한 데이터 모델링을 적용해야 함.

만약 이 같은 엘라스틱서치의 철학을 인지하지 못하고 데이터 모델링을 시작한 경우에는 이후 클러스터 설계부터 데이터 사이징, 쿼리 등 다양한 요소에서 문제점이 드러날 수 밖에 없음.

엘라스틱에서 관계형 데이터 모델링 방법은 크게 4가지가 있으며 각각 기술적 장단점이 분명합니다. 때문에 자신의 데이터 특성 및 상황을 고려하여 적절한 모델링 방법을 활용 필요

**1) Parent-Child 모델링**\
엘라스틱서치가 제공하는 Join data type을 바탕으로 설계하는 방법입니다. 하나의 인덱스에서 Parent와 Child 도큐먼트 간에 Join type으로 Parent, Child를 구분하고 Parent와 Child 도큐먼트에서 같은 라우팅 ID를 키로 제공하여 같은 샤드(Shard)에 위치하게끔 설계합니다. 이 방식은 전체 도큐먼트에서 업데이트와 삭제가 빈번하고 1:N 관계의 구조일 때 고려해 볼 만합니다.

*   유의 사항

    > * 라우팅 ID를 별도로 관리해야 하는 점
    > * 기존 쿼리에 비해 내부 연산이 많아 쿼리 자체에 부하가 있는 점(has\_parent·has\_child Query)
    > * 집계(Aggregation) 일부 쿼리 기능에 대한 제약

**2) Nested 모델링**\
엘라스틱서치에서 Nested data type을 활용해 설계하는 방법입니다. 하나의 인덱스에서 Nested data type을 선언하고 오브젝트 속성들을 정의하여 연속(Array)하게 배치하는 방식입니다. 두 개 이상의 속성을 가진 오브젝트를 배열(Array) 구조로 표현해야 할 때 고려해 볼 수 있습니다. 다만 이 방식을 사용할 경우 쿼리(Query)·집계(Aggregation) 및 업데이트(Update) 시 유의해야 합니다. Nested Type은 내부적으로 Nested Object 별로 저장하기 때문에 Nested가 포함된 문서 하나를 저장할 때 실제 내부적으로는 Nested Array Size + 1만큼 저장하게 됩니다. 따라서 별도의 Nested Query를 작성해야 하고 업데이트 시 이러한 유의 사항을 고려해 디자인 해야 합니다.

**3) Application Side Join 모델링**\
기본 키(Primary Key)를 기준으로 관계(Relation) 있는 엔티티(Entity)들을 서로 다른 도큐먼트에 배치하여 Application side에서 키를 기준으로 조인(Join)하여 처리하는 방식입니다. 이 모델링은 1:1 관계의 구조로 기존 쿼리와 집계(Aggregation)를 그대로 사용해야 할 때 고려해 볼 수 있습니다. 엘라스틱서치 쿼리를 그대로 사용 가능한 장점이 있으나 Application side에서 키 값을 기준으로 2회 이상 조회하여 가공해야 하므로 페이징 및 정렬(Sorting) 처리를 유의해야 합니다. 일반적으로 관계가 있는 단순 조회 목적일 때 고려해 볼 만한 방법입니다.

**4) Denormalization 모델링**\
데이터 전체를 비정규화하여 인덱싱하는 방법으로 각 데이터의 중복을 허용하여 조인(Join)이 필요하지 않도록 합니다. 이 기법은 조인(Join) 연산 자체가 필요 없으며 쿼리 시점에서 최고의 성능을 낼 수 있다는 점 때문에 잘 활용하면 최고의 모델링이 될 수 있습니다. 다만 데이터 크기가 기하급수적으로 증가할 수 있는 구조이기 때문에 공통 필드의 변경이 잦거나 한정된 물리 서버로 구성해야 한다면 유의해서 사용해야 합니다.
